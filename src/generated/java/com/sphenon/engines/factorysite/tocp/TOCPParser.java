/* Generated By:JavaCC: Do not edit this line. TOCPParser.java */

/****************************************************************************
  Copyright 2001-2018 Sphenon GmbH

  Licensed under the Apache License, Version 2.0 (the "License"); you may not
  use this file except in compliance with the License. You may obtain a copy
  of the License at http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
  License for the specific language governing permissions and limitations
  under the License.
*****************************************************************************/
package com.sphenon.engines.factorysite.tocp;

import com.sphenon.basics.context.*;

import java.io.Reader;
import java.io.IOException;

import java.util.Map;
import java.util.HashMap;
import java.util.Vector;

public class TOCPParser implements TOCPParserConstants {

  public TOCPASTNode result;
  public boolean enabled;

  public TOCPParser(CallContext context, Reader in) {
      this(in);
  }

  public String getPosition() {
      return   "[line "    + jj_input_stream.getBeginLine()
                           + (jj_input_stream.getBeginLine() != jj_input_stream.getEndLine() ? ("-" + jj_input_stream.getEndLine()) : "")
             + ", column " + jj_input_stream.getBeginColumn()
                           + (jj_input_stream.getBeginColumn() != jj_input_stream.getEndColumn() ? ("-" + jj_input_stream.getEndColumn()) : "")
             + "]";
  }

  final public Vector TOCPList(CallContext context, Vector vtan, boolean anonymous_wrap) throws ParseException {
                                                                              TOCPASTNode tan;
    if (vtan == null) { vtan = new Vector(); }
    int index=1;
    tan = TOCP(context);
                          if (anonymous_wrap) {
                            TOCPASTNode wtan = new TOCPASTNode(context);
                            wtan.setName(context, "entry"+(index++));
                            wtan.addPart(context, tan);
                            vtan.add(wtan);
                          } else {
                            vtan.add(tan);
                          }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      vtan = TOCPList(context, vtan, anonymous_wrap);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    {if (true) return vtan;}
    throw new Error("Missing return statement in function");
  }

  final public String TOCPString() throws ParseException {
                        Token t;
    String result;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED:
      t = jj_consume_token(QUOTED);
                         result = t.image.substring(1,t.image.length()-1);
      break;
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
                         result = t.image;
      break;
    case NUMBER:
      t = jj_consume_token(NUMBER);
                         result = t.image;
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public TOCPASTNode TOCP(CallContext context) throws ParseException {
                                          Token t; String s;
    TOCPASTNode result = new TOCPASTNode(context);
    Vector vtan = null;
    String name  = null;
    String value = null;
    String t1 = null;
    boolean ts_is_name = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case NUMBER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        t = jj_consume_token(IDENTIFIER);
        break;
      case NUMBER:
        t = jj_consume_token(NUMBER);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
                                                     t1 = t.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        jj_consume_token(LT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          jj_consume_token(WS);
          break;
        default:
          jj_la1[5] = jj_gen;
          ;
        }
                            ts_is_name = true;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
        case NUMBER:
        case QUOTED:
          s = TOCPString();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            jj_consume_token(WS);
            break;
          default:
            jj_la1[6] = jj_gen;
            ;
          }
                                                             result.setClass(context, s);
          break;
        default:
          jj_la1[7] = jj_gen;
          ;
        }
        label_1:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case HASH:
          case MINUS:
          case PLUS:
          case QMARK:
          case PERCENT:
          case EMARK:
          case CARET:
          case TILDE:
          case STAR:
            ;
            break;
          default:
            jj_la1[8] = jj_gen;
            break label_1;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case HASH:
            jj_consume_token(HASH);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[9] = jj_gen;
              ;
            }
            s = TOCPString();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[10] = jj_gen;
              ;
            }
                                                                 result.setOId(context, s);
            break;
          case PLUS:
            jj_consume_token(PLUS);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[11] = jj_gen;
              ;
            }
            s = TOCPString();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[12] = jj_gen;
              ;
            }
                                                                 result.setFactory(context, s);
            break;
          case QMARK:
            jj_consume_token(QMARK);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[13] = jj_gen;
              ;
            }
            s = TOCPString();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[14] = jj_gen;
              ;
            }
                                                                 result.setRetriever(context, s);
            break;
          case EMARK:
            jj_consume_token(EMARK);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[15] = jj_gen;
              ;
            }
            s = TOCPString();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[16] = jj_gen;
              ;
            }
                                                                 result.setLocator(context, s);
            break;
          case PERCENT:
            jj_consume_token(PERCENT);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[17] = jj_gen;
              ;
            }
            s = TOCPString();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[18] = jj_gen;
              ;
            }
                                                                 result.setIdRef(context, s);
            break;
          case CARET:
            jj_consume_token(CARET);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[19] = jj_gen;
              ;
            }
            s = TOCPString();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[20] = jj_gen;
              ;
            }
                                                                 result.setParameter(context, s);
            break;
          case MINUS:
            jj_consume_token(MINUS);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[21] = jj_gen;
              ;
            }
                                                                 result.setNull(context, "true");
            break;
          case TILDE:
            jj_consume_token(TILDE);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[22] = jj_gen;
              ;
            }
            s = TOCPString();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[23] = jj_gen;
              ;
            }
                                                                 result.setNameSpace(context, s);
            break;
          case STAR:
            jj_consume_token(STAR);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              jj_consume_token(WS);
              break;
            default:
              jj_la1[24] = jj_gen;
              ;
            }
                                                                 result.setTypeCheck(context, "allow_dynamic");
            break;
          default:
            jj_la1[25] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(GT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          jj_consume_token(WS);
          break;
        default:
          jj_la1[26] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        jj_consume_token(EQ);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          jj_consume_token(WS);
          break;
        default:
          jj_la1[28] = jj_gen;
          ;
        }
                            ts_is_name = true;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case QUOTED:
          t = jj_consume_token(QUOTED);
                                          value = t.image.substring(1,t.image.length()-1);
          break;
        case IDENTIFIER:
          t = jj_consume_token(IDENTIFIER);
                                          value = t.image;
          break;
        case NUMBER:
          t = jj_consume_token(NUMBER);
                                          value = t.image;
          break;
        case OBC:
        case OBK:
          vtan = TOCPBlock(context);
                                          value = null;
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          jj_consume_token(WS);
          break;
        default:
          jj_la1[30] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      break;
    case QUOTED:
      t = jj_consume_token(QUOTED);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[32] = jj_gen;
        ;
      }
                                value = t.image.substring(1,t.image.length()-1);
      break;
    case OBC:
    case OBK:
      vtan = TOCPBlock(context);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (ts_is_name) { name = t1; }
    else            { value = t1; }
    if (name != null) {
      result.setName(context, name);
    }
    if (value != null) {
      result.setValue(context, value);
    }
    if (vtan != null) {
      result.setParts(context, vtan);
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Vector TOCPBlock(CallContext context) throws ParseException {
    Vector vtan = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OBC:
      jj_consume_token(OBC);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case NUMBER:
      case QUOTED:
      case OBC:
      case OBK:
        vtan = TOCPList(context, null, false);
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
      jj_consume_token(CBC);
      break;
    case OBK:
      jj_consume_token(OBK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[37] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case NUMBER:
      case QUOTED:
      case OBC:
      case OBK:
        vtan = TOCPList(context, null, true);
        break;
      default:
        jj_la1[38] = jj_gen;
        ;
      }
      jj_consume_token(CBK);
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return vtan;}
    throw new Error("Missing return statement in function");
  }

  public TOCPParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[40];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x10,0x40,0xe,0x6,0x10,0x10,0x10,0xe,0x3fe000,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x3fe000,0x10,0x800,0x10,0x28e,0x10,0x20,0x10,0x10,0x28e,0x10,0x28e,0x10,0x28e,0x280,};
   }

  public TOCPParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public TOCPParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TOCPParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  public TOCPParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TOCPParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  public TOCPParser(TOCPParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  public void ReInit(TOCPParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[22];
    for (int i = 0; i < 22; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 40; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 22; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}

/* Generated By:JavaCC: Do not edit this line. MDOCPParser.java */

/****************************************************************************
  Copyright 2001-2018 Sphenon GmbH

  Licensed under the Apache License, Version 2.0 (the "License"); you may not
  use this file except in compliance with the License. You may obtain a copy
  of the License at http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
  License for the specific language governing permissions and limitations
  under the License.
*****************************************************************************/
package com.sphenon.engines.factorysite.mdocp;

import com.sphenon.basics.context.*;
import com.sphenon.basics.exception.*;
import com.sphenon.basics.notification.*;
import com.sphenon.basics.customary.*;
import com.sphenon.basics.data.*;
import com.sphenon.basics.graph.*;
import com.sphenon.basics.validation.returncodes.*;

import com.sphenon.engines.factorysite.*;
import com.sphenon.engines.factorysite.tocp.*;
import com.sphenon.engines.factorysite.factories.*;

import java.io.*;
import java.util.*;

public class MDOCPParser implements MDOCPParserConstants {

    static protected MDOCPParser mdocp_parser;
    static protected MDOCPParser abbreviation_parser;
    static protected boolean debug = true;

    static protected MDOCPParser getMDOCPParser(CallContext context, String string, String source_info) throws ParseException {
        if (mdocp_parser == null) { mdocp_parser = new MDOCPParser(context, string, source_info); }
        else                      { mdocp_parser.ReInit(context, string, source_info); }
        return mdocp_parser;
    }

    static protected MDOCPParser getMDOCPParser(CallContext context, InputStream stream, String source_info) throws ParseException, IOException {
        if (mdocp_parser == null) { mdocp_parser = new MDOCPParser(context, stream, source_info); }
        else                      { mdocp_parser.ReInit(context, stream, source_info); }
        return mdocp_parser;
    }

    static synchronized public TOCPASTNode parseMDOCP(CallContext context, String string, String source_info) throws ParseException {
        return getMDOCPParser(context, string, source_info).MDOCP(context);
    }

    static synchronized public TOCPASTNode parseMDOCP(CallContext context, InputStream stream, String source_info) throws ParseException, IOException {
        return getMDOCPParser(context, stream, source_info).MDOCP(context);
    }

    static synchronized public TOCPASTNode parseMDOCP(CallContext context, File file) throws ParseException, IOException {
        FileInputStream fis = new FileInputStream(file);
        TOCPASTNode result = getMDOCPParser(context, fis, file.getPath()).MDOCP(context);
        fis.close();
        return result;
    }

    static protected MDOCPParser getAbbreviationParser(CallContext context, String string, String source_info) throws ParseException {
        if (abbreviation_parser == null) { abbreviation_parser = new MDOCPParser(context, string, source_info); }
        else                             { abbreviation_parser.ReInit(context, string, source_info); }
        return abbreviation_parser;
    }

    static protected MDOCPParser getAbbreviationParser(CallContext context, InputStream stream, String source_info) throws ParseException, IOException {
        if (abbreviation_parser == null) { abbreviation_parser = new MDOCPParser(context, stream, source_info); }
        else                             { abbreviation_parser.ReInit(context, stream, source_info); }
        return abbreviation_parser;
    }

    static synchronized public void parseAbbreviations(CallContext context, String string, String source_info, Map<String,List<String>> abbreviations, Map<String,List<String>> default_names_map, Map<String,List<String>> abbreviation_context_map, Map<String,List<KeyValue>> default_ocpmetavalues_map) throws ParseException {
        getAbbreviationParser(context, string, source_info).Abbreviations(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map);
    }

    static synchronized public void parseAbbreviations(CallContext context, InputStream stream, String source_info, Map<String,List<String>> abbreviations, Map<String,List<String>> default_names_map, Map<String,List<String>> abbreviation_context_map, Map<String,List<KeyValue>> default_ocpmetavalues_map) throws ParseException, IOException {
        getAbbreviationParser(context, stream, source_info).Abbreviations(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map);
    }

    static synchronized public void parseAbbreviations(CallContext context, File file, Map<String,List<String>> abbreviations, Map<String,List<String>> default_names_map, Map<String,List<String>> abbreviation_context_map, Map<String,List<KeyValue>> default_ocpmetavalues_map) throws ParseException, IOException {
        FileInputStream fis = new FileInputStream(file);
        getAbbreviationParser(context, fis, file.getPath()).Abbreviations(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map);
        fis.close();
    }

    protected String source_info;

    public MDOCPParser (CallContext context, String string, String source_info) {
        this(new BufferedReader(new StringReader(string)));
        this.source_info = source_info;
    }

    public void ReInit (CallContext context, String string, String source_info) {
        ReInit(new BufferedReader(new StringReader(string)));
        this.source_info = source_info;
    }

    public MDOCPParser (CallContext context, InputStream stream, String source_info) throws IOException {
        this(new BufferedReader(new InputStreamReader(stream, "UTF-8")));
        this.source_info = source_info;
    }

    public void ReInit (CallContext context, InputStream stream, String source_info) throws IOException {
        ReInit(new BufferedReader(new InputStreamReader(stream, "UTF-8")));
        this.source_info = source_info;
    }

    public String getPosition(CallContext context) {
        return   "[line "    + jj_input_stream.getBeginLine()
                             + (jj_input_stream.getBeginLine() != jj_input_stream.getEndLine() ? ("-" + jj_input_stream.getEndLine()) : "")
               + ", column " + jj_input_stream.getBeginColumn()
                             + (jj_input_stream.getBeginColumn() != jj_input_stream.getEndColumn() ? ("-" + jj_input_stream.getEndColumn()) : "")
               + "]";
    }

    static protected class KeyValue {
        public KeyValue () { }
        public KeyValue (String key, String value) { this.key = key; this.value = value; }
        public String key;
        public String value;
        public TOCPASTNode value_node;
    }

    protected void lookupAbbreviations(CallContext context, String namespace, Map<String,List<String>> abbreviations, Map<String,List<String>> default_names_map, Map<String,List<String>> abbreviation_context_map, Map<String,List<KeyValue>> default_ocpmetavalues_map) {
        String path = namespace.replaceAll("/([0-9.]+)(?=/|$)","-$1");
        OCPFinder ocp_finder = new OCPFinder(context, path, null, null, null);
        try {
            ocp_finder.findOCP(context);
        } catch (ValidationFailure vf) {
            CustomaryContext.create((Context)context).throwVerificationFailure(context, vf, "While parsing MDOCP '%(info)', defining resource '%(path)' for namespace '%(namespace)' not found", "path", path, "namespace", namespace, "info", source_info);
            throw (ExceptionVerificationFailure) null; // compiler insists
        }
        if (ocp_finder.found == false) {
            CustomaryContext.create((Context)context).throwConfigurationError(context, "While parsing MDOCP '%(info)', defining resource '%(path)' for namespace '%(namespace)' not found", "path", path, "namespace", namespace, "info", source_info);
            throw (ExceptionConfigurationError) null; // compiler insists
        }
        Data_MediaObject data = ((Data_MediaObject)(((NodeContent_Data)(((TreeLeaf) ocp_finder.result_node).getContent(context))).getData(context)));
        InputStream stream = data.getStream(context);
        try {
            parseAbbreviations(context, stream, path, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map);
        } catch (ParseException pe) {
            CustomaryContext.create((Context)context).throwConfigurationError(context, pe, "While parsing MDOCP '%(info)', subparsing of defining resource '%(path)' for namespace '%(namespace)' failed", "path", path, "namespace", namespace, "info", source_info);
            throw (ExceptionConfigurationError) null; // compiler insists
        } catch (IOException ioe) {
            CustomaryContext.create((Context)context).throwConfigurationError(context, ioe, "While parsing MDOCP '%(info)', subparsing of defining resource '%(path)' for namespace '%(namespace)' failed", "path", path, "namespace", namespace, "info", source_info);
            throw (ExceptionConfigurationError) null; // compiler insists
        }
        if (debug) {
            System.err.println("~~ Abbreviations ~~~~~~~~~~~~~~~~~~~~~");
            for (Map.Entry<String,List<String>> abbreviation : abbreviations.entrySet()) {
                System.err.println(abbreviation.getKey() + " => ");
                for (String value : abbreviation.getValue()) {
                    System.err.println("     - " + value);
                }
            }
            System.err.println("~~ Default Names ~~~~~~~~~~~~~~~~~~~~~");
            for (Map.Entry<String,List<String>> default_names : default_names_map.entrySet()) {
                System.err.println(default_names.getKey() + " => ");
                for (String value : default_names.getValue()) {
                    System.err.println("     - " + value);
                }
            }
            System.err.println("~~ Default Values ~~~~~~~~~~~~~~~~~~~~");
            for (Map.Entry<String,List<KeyValue>> default_ocpmetavalues : default_ocpmetavalues_map.entrySet()) {
                System.err.println(default_ocpmetavalues.getKey() + " => ");
                for (KeyValue value : default_ocpmetavalues.getValue()) {
                    System.err.println("     - " + value.key + " : " + value.value);
                }
            }
            System.err.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        }
    }

    protected String substitute(CallContext context, Map<String,List<String>> abbreviations, String word) {
        if (word == null || word.isEmpty() || abbreviations == null || abbreviations.containsKey(word) == false) { return word; }
        return abbreviations.get(word).get(0);
    }

    protected void checkAssignment(CallContext context, KeyValue entry) {
        if (entry.value != null) {
            int pos = entry.value.indexOf('=');
            if (pos != -1) {
                entry.key   = entry.value.substring(0, pos);
                entry.value = entry.value.substring(pos + 1);
            }
        }
    }

    protected void applyOCPMeta(CallContext context, TOCPASTNode node, String key, String value) {
        switch (key) {
            case BuildTextKeywords.Class                  :
            case BuildTextKeywords.CLASS_UC               : node.setClass(context, value); break;
            case BuildTextKeywords.OId                    :
            case BuildTextKeywords.OID_UC                 : node.setOId(context, value); break;
            case BuildTextKeywords.Factory                :
            case BuildTextKeywords.FACTORY_UC             : node.setFactory(context, value); break;
            case BuildTextKeywords.Retriever              :
            case BuildTextKeywords.RETRIEVER_UC           : node.setRetriever(context, value); break;
            case BuildTextKeywords.Method                 : node.setMethod(context, value); break;
            case BuildTextKeywords.ComponentType          : node.setComponentType(context, value); break;

            case BuildTextKeywords.NameSpace              : node.setNameSpace(context, value); break;
            case BuildTextKeywords.OCPId                  : node.setOCPId(context, value); break;
            case BuildTextKeywords.Signature              :
            case BuildTextKeywords.SIGNATURE_UC           : node.setSignature(context, value); break;
            case BuildTextKeywords.Define                 :
            case BuildTextKeywords.DEFINE_UC              : node.setDefine(context, value); break;
            case BuildTextKeywords.Evaluator              : node.setEvaluator(context, value); break;

            case BuildTextKeywords.Name                   : node.setName(context, value); break;
            case BuildTextKeywords.AssignTo               : node.setAssignTo(context, value); break;
            case BuildTextKeywords.Out                    : node.setOut(context, value); break;

            case BuildTextKeywords.Parameter              :
            case BuildTextKeywords.PARAMETER_UC           : node.setParameter(context, value); break;
            case BuildTextKeywords.OptionalParameter      : node.setOptionalParameter(context, value); break;
            case BuildTextKeywords.IdRef                  : node.setIdRef(context, value); break;
            case BuildTextKeywords.OptionalIdRef          : node.setOptionalIdRef(context, value); break;
            case BuildTextKeywords.OIdRef                 : node.setOIdRef(context, value); break;

            case BuildTextKeywords.TypeCheck              : node.setTypeCheck(context, value); break;
            case BuildTextKeywords.ArgumentCheck          : node.setArgumentCheck(context, value); break;
            case BuildTextKeywords.Singleton              : node.setSingleton(context, value); break;
            case BuildTextKeywords.DynamicParameters      : node.setDynamicParameters(context, value); break;
            case BuildTextKeywords.Listener               : node.setListener(context, value); break;
            case BuildTextKeywords.Alias                  : node.setAlias(context, value); break;

            case BuildTextKeywords.If                     :
            case BuildTextKeywords.IF_UC                  : node.setIf(context, value); break;
            case BuildTextKeywords.ForEach                :
            case BuildTextKeywords.FOREACH_UC             : node.setForEach(context, value); break;
            case BuildTextKeywords.Switch                 : node.setSwitch(context, value); break;

            case BuildTextKeywords.Content                : node.setContent(context, value); break;
            case BuildTextKeywords.Complex                : node.setComplex(context, value); break;

            case BuildTextKeywords.Expression             :
            case BuildTextKeywords.EXPRESSION_UC          : node.setExpression(context, value); break;
            case BuildTextKeywords.ExpressionText         :
            case BuildTextKeywords.EXPRESSION_TEXT_UC     : node.setExpressionText(context, value); break;
            case BuildTextKeywords.ExpressionValue        :
            case BuildTextKeywords.EXPRESSION_VALUE_UC    : node.setExpressionValue(context, value); break;

            case BuildTextKeywords.Locator                :
            case BuildTextKeywords.LOCATOR_UC             : node.setLocator(context, value); break;
            case BuildTextKeywords.LocatorBase            : node.setLocatorBase(context, value); break;
            case BuildTextKeywords.LocatorBaseOIdRef      : node.setLocatorBaseOIdRef(context, value); break;
            case BuildTextKeywords.LocatorBaseParameter   : node.setLocatorBaseParameter(context, value); break;

            case BuildTextKeywords.Null                   : node.setNull(context, value); break;

            case BuildTextKeywords.Base                   : node.setBase(context, value); break;
            case BuildTextKeywords.Polymorphic            : node.setPolymorphic(context, value); break;
            case BuildTextKeywords.Override               : node.setOverride(context, value); break;

            case BuildTextKeywords.Catch                  : node.setCatch(context, value); break;
            case BuildTextKeywords.AppliesTo              : node.setAppliesTo(context, value); break;
            case BuildTextKeywords.Pass                   : node.setPass(context, value); break;

            case BuildTextKeywords.Meta                   : node.setMeta(context, value); break;
            case BuildTextKeywords.Code                   : node.setCode(context, value); break;
        }
    }

    protected TOCPASTNode processLine(CallContext context, String first_name, List<KeyValue> line, Map<String,List<String>> abbreviations, Map<String,List<String>> default_names_map, Map<String,List<String>> abbreviation_context_map, Map<String,List<KeyValue>> default_ocpmetavalues_map) {
        TOCPASTNode node = new TOCPASTNode(context);
        if (debug) { System.err.println("~*~ " + first_name); }
        node.setName(context, first_name);
        List<String> default_names = default_names_map.get(first_name);
        List<KeyValue> default_ocpmetavalues = default_ocpmetavalues_map.get(first_name);
        if (default_ocpmetavalues != null) {
            for (KeyValue ocpmeta : default_ocpmetavalues) {
                if (debug) { System.err.println("  ~ @ " + ocpmeta.key + " -> " + ocpmeta.value); }
                applyOCPMeta(context, node, ocpmeta.key, ocpmeta.value);
            }
        }
        int current_default = 1; // first is substitution
        for (KeyValue entry : line) {
            String name = (entry.key == null || entry.key.isEmpty() ? default_names == null || default_names.size() <= current_default ? null : default_names.get(current_default++) : entry.key);
            String value = entry.value;
            TOCPASTNode part = entry.value_node;
            if (debug) { System.err.println("  ~ " + name + "[" + entry.key + "] -> " + (value == null ? "" : ("<<" + value + ">>")) +  (entry.value_node == null ? "" : ("[[" + entry.value_node.getName(context) + "]]"))); }
            if (name != null) {
                if (name.startsWith("@")) {
                    applyOCPMeta(context, node, name.substring(1), value);
                } else {
                    if (part == null) {
                        part = new TOCPASTNode(context);
                        part.setName(context, name);
                        part.setValue(context, value);
                    }
                    node.addPart(context, part);
                }
            }
        }
        return node;
    }

    protected boolean isChildOf(CallContext context, TOCPASTNode child, TOCPASTNode parent, Map<String,List<String>> abbreviation_context_map) {
        if (child == null || parent == null) { return false; }
        String child_name  = child.getName(context);
        String parent_name = parent.getName(context);
        List<String> abbreviation_contexts = abbreviation_context_map.get(child_name);
        return (abbreviation_contexts.contains(parent_name) ? true : false);
    }

    protected String format(CallContext context, TOCPASTNode node) {
        if (node == null) { return "---"; }
        String name = node.getName(context);
        return name.length() <= 16 ? name : name.substring(0, 16);
    }

  final public String SlashedPath() throws ParseException {
                         Token token; String result; String postfix = null;
    token = jj_consume_token(XALNUM);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLASH:
      jj_consume_token(SLASH);
      postfix = SlashedPath();
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
                                                         result = token.image + (postfix == null ? "" : ("/" + postfix));
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String Quoted() throws ParseException {
                    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARACTER_LITERAL:
      token = jj_consume_token(CHARACTER_LITERAL);
      break;
    case STRING_LITERAL:
      token = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return token.image.substring(1, token.image.length() - 1);}
    throw new Error("Missing return statement in function");
  }

  final public String UnspacedWord() throws ParseException {
                          Token token; StringBuffer value;
    value = new StringBuffer();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case XALNUM:
      token = jj_consume_token(XALNUM);
                                    value.append(token.image);
      break;
    case SLASH:
      token = jj_consume_token(SLASH);
                                    value.append(token.image);
      break;
    case ANY:
      token = jj_consume_token(ANY);
                                    value.append(token.image);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case XALNUM:
      case SLASH:
      case AT:
      case ANY:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHARACTER_LITERAL:
        token = jj_consume_token(CHARACTER_LITERAL);
                                    value.append(token.image);
        break;
      case STRING_LITERAL:
        token = jj_consume_token(STRING_LITERAL);
                                    value.append(token.image);
        break;
      case XALNUM:
        token = jj_consume_token(XALNUM);
                                    value.append(token.image);
        break;
      case SLASH:
        token = jj_consume_token(SLASH);
                                    value.append(token.image);
        break;
      case AT:
        token = jj_consume_token(AT);
                                    value.append(token.image);
        break;
      case ANY:
        token = jj_consume_token(ANY);
                                    value.append(token.image);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return value.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String Word() throws ParseException {
                  String word;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case XALNUM:
    case SLASH:
    case ANY:
      word = UnspacedWord();
      break;
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
      word = Quoted();
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return word;}
    throw new Error("Missing return statement in function");
  }

  final public void EOL() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
      jj_consume_token(COMMENT);
      break;
    case NL:
      jj_consume_token(NL);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Assignment(CallContext context, Map<String,List<String>> abbreviations, Map<String,List<String>> default_names_map, Map<String,List<String>> abbreviation_context_map, Map<String,List<KeyValue>> default_ocpmetavalues_map, KeyValue entry) throws ParseException {
                                                                                                                                                                                                                                                      String word2; List<KeyValue> sub_line;
    jj_consume_token(EQUAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
                                    entry.key = entry.value; entry.value = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case XALNUM:
    case SLASH:
    case ANY:
      word2 = Word();
                                    entry.value = substitute(context, abbreviations, word2);
      break;
    case OPBRC:
      jj_consume_token(OPBRC);
                                      sub_line = new ArrayList<KeyValue>();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case XALNUM:
      case SLASH:
      case AT:
      case ANY:
        Entries(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map, sub_line);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      jj_consume_token(CLBRC);
                                      entry.value_node = processLine(context, entry.key, sub_line, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Entries(CallContext context, Map<String,List<String>> abbreviations, Map<String,List<String>> default_names_map, Map<String,List<String>> abbreviation_context_map, Map<String,List<KeyValue>> default_ocpmetavalues_map, List<KeyValue> line) throws ParseException {
                                                                                                                                                                                                                                                        String word1; String word2;
    KeyValue entry = new KeyValue(); line.add(entry);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AT:
      jj_consume_token(AT);
      word1 = Word();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      jj_consume_token(EQUAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      word2 = Word();
                                                                       entry.key = '@' + word1; entry.value = word2;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case XALNUM:
        case SLASH:
        case AT:
        case ANY:
          Entries(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map, line);
          break;
        default:
          jj_la1[13] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      break;
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case XALNUM:
    case SLASH:
    case ANY:
      word1 = Word();
                                entry.value = substitute(context, abbreviations, word1);
                                checkAssignment(context, entry);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case EQUAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          jj_consume_token(WS);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case XALNUM:
          case SLASH:
          case EQUAL:
          case AT:
          case ANY:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EQUAL:
              Assignment(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map, entry);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case WS:
                jj_consume_token(WS);
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case CHARACTER_LITERAL:
                case STRING_LITERAL:
                case XALNUM:
                case SLASH:
                case AT:
                case ANY:
                  Entries(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map, line);
                  break;
                default:
                  jj_la1[15] = jj_gen;
                  ;
                }
                break;
              default:
                jj_la1[16] = jj_gen;
                ;
              }
              break;
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case XALNUM:
            case SLASH:
            case AT:
            case ANY:
              Entries(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map, line);
              break;
            default:
              jj_la1[17] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[18] = jj_gen;
            ;
          }
          break;
        case EQUAL:
          Assignment(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map, entry);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            jj_consume_token(WS);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case XALNUM:
            case SLASH:
            case AT:
            case ANY:
              Entries(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map, line);
              break;
            default:
              jj_la1[19] = jj_gen;
              ;
            }
            break;
          default:
            jj_la1[20] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public TOCPASTNode Line(CallContext context, Map<String,List<String>> abbreviations, Map<String,List<String>> default_names_map, Map<String,List<String>> abbreviation_context_map, Map<String,List<KeyValue>> default_ocpmetavalues_map) throws ParseException {
                                                                                                                                                                                                                                       List<KeyValue> line; String name;
    line = new ArrayList<KeyValue>();
    name = Word();
                  name = substitute(context, abbreviations, name);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case XALNUM:
      case SLASH:
      case AT:
      case ANY:
        Entries(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map, line);
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    {if (true) return processLine(context, name, line, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map);}
    throw new Error("Missing return statement in function");
  }

  final public void Substitutions(CallContext context, List<String> substitutions, List<KeyValue> default_ocpmetavalues) throws ParseException {
                                                                                                              String substitution; String default_value = null; Token at=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AT:
      at = jj_consume_token(AT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    substitution = Word();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      default_value = Word();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
      if (default_value == null) { substitutions.add((at != null ? "@" : "") + substitution); }
      else { if (at == null) {
                 CustomaryContext.create((Context)context).throwConfigurationError(context, "In MDOCP '%(info)' line '%(line)', a default value '%(value)' was defined for a name '%(name)' that is not an OCP meta name (not starting with '@')", "info", source_info, "name", substitution, "value", default_value, "line", getPosition(context));
                 {if (true) throw (ExceptionConfigurationError) null;} // compiler insists
             }
             default_ocpmetavalues.add(new KeyValue(substitution, default_value)); }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      Substitutions(context, substitutions, default_ocpmetavalues);
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
  }

  final public void AbbreviationContext(CallContext context, List<String> abbreviation_context) throws ParseException {
                                                                                     String a_context;
    a_context = Word();
      abbreviation_context.add(a_context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
    case SEMICOLON:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            jj_consume_token(WS);
            break;
          default:
            jj_la1[33] = jj_gen;
            ;
          }
          AbbreviationContext(context, abbreviation_context);
          break;
        default:
          jj_la1[34] = jj_gen;
          ;
        }
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          jj_consume_token(WS);
          break;
        default:
          jj_la1[35] = jj_gen;
          ;
        }
        AbbreviationContext(context, abbreviation_context);
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
  }

  final public void Abbreviation(CallContext context, Map<String,List<String>> abbreviations, Map<String,List<String>> default_names_map, Map<String,List<String>> abbreviation_context_map, Map<String,List<KeyValue>> default_ocpmetavalues_map) throws ParseException {
                                                                                                                                                                                                                                        String abbreviation;
    List<String> substitutions = new ArrayList<String>();
    List<KeyValue> default_ocpmetavalues = new ArrayList<KeyValue>();
    List<String> abbreviation_context = new ArrayList<String>();
    jj_consume_token(AT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[38] = jj_gen;
      ;
    }
    abbreviation = Word();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPBRK:
      jj_consume_token(OPBRK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[40] = jj_gen;
        ;
      }
      AbbreviationContext(context, abbreviation_context);
      jj_consume_token(CLBRK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[42] = jj_gen;
      ;
    }
    jj_consume_token(EQUAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    Substitutions(context, substitutions, default_ocpmetavalues);
    abbreviations.put(abbreviation, substitutions);
    if (substitutions.size() > 0) {
        abbreviations.put(substitutions.get(0), substitutions);
        default_names_map.put(substitutions.get(0), substitutions);
        abbreviation_context_map.put(substitutions.get(0), abbreviation_context);
        default_ocpmetavalues_map.put(substitutions.get(0), default_ocpmetavalues);
    }
  }

  final public void Abbreviations(CallContext context, Map<String,List<String>> abbreviations, Map<String,List<String>> default_names_map, Map<String,List<String>> abbreviation_context_map, Map<String,List<KeyValue>> default_ocpmetavalues_map) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AT:
      Abbreviation(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map);
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NL:
      case COMMENT:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_2;
      }
      EOL();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[47] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AT:
        Abbreviation(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map);
        break;
      default:
        jj_la1[48] = jj_gen;
        ;
      }
    }
    jj_consume_token(0);
  }

  final public TOCPASTNode MDOCP(CallContext context) throws ParseException {
                                           Token token; Token indent = null; int i0, i1, i2; Stack<Integer> indents; TOCPASTNode parent = null; TOCPASTNode last = null; TOCPASTNode root = null; TOCPASTNode new_node; Stack<TOCPASTNode> nodes;
    indents = new Stack<Integer>();
    nodes   = new Stack<TOCPASTNode>();
    i0=i1=-1;
    String namespace;
    Map<String,List<String>> abbreviations = new HashMap<String,List<String>>();
    Map<String,List<KeyValue>> default_ocpmetavalues_map = new HashMap<String,List<KeyValue>>();
    Map<String,List<String>> default_names_map = new HashMap<String,List<String>>();
    Map<String,List<String>> abbreviation_context_map = new HashMap<String,List<String>>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NL:
      case COMMENT:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_3;
      }
      EOL();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[51] = jj_gen;
        ;
      }
    }
    jj_consume_token(AT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[52] = jj_gen;
      ;
    }
    namespace = SlashedPath();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
      lookupAbbreviations(context, namespace, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map);
      if (debug) { System.err.println("         #indent   #last  #stack  node           last            parent          stack"); }
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NL:
      case COMMENT:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_4;
      }
        indent = null;
      EOL();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        indent = jj_consume_token(WS);
        break;
      default:
        jj_la1[55] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case XALNUM:
      case SLASH:
      case AT:
      case ANY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case XALNUM:
        case SLASH:
        case ANY:
          new_node = Line(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map);
              i2 = (indent == null || indent.image == null ? 0 : indent.image.length());
              if (debug) { System.err.println(String.format("LINE    %8d%8d[%2d]%4d  %16s%16s%16s[%2d] %16s", i2, i1, indents.size(), indents.size() == 0 ? -1 : indents.peek(), format(context, new_node), format(context, last), format(context, parent), nodes.size(), nodes.size() == 0 ? "---" : format(context, nodes.peek()))); }
              if (i1 == -1) {
                  i0 = i1 = i2;
                  root = last = new_node;
                  if (debug) { System.err.println(String.format("INITIAL %8d%8d[%2d]%4d  %16s%16s%16s[%2d] %16s", i2, i1, indents.size(), indents.size() == 0 ? -1 : indents.peek(), format(context, new_node), format(context, last), format(context, parent), nodes.size(), nodes.size() == 0 ? "---" : format(context, nodes.peek()))); }
              } else {
                  if (i2 >  i1 || (i2 == i1 && isChildOf(context, new_node, last, abbreviation_context_map)))  {
                      indents.push(i1);
                      nodes.push(parent);
                      i1 = i2;
                      parent = last;
                      if (debug) { System.err.println(String.format("PUSHED  %8d%8d[%2d]%4d  %16s%16s%16s[%2d] %16s", i2, i1, indents.size(), indents.size() == 0 ? -1 : indents.peek(), format(context, new_node), format(context, last), format(context, parent), nodes.size(), nodes.size() == 0 ? "---" : format(context, nodes.peek()))); }
                  } else {
                      while (    (i2 < i1  && (indents.size() == 0 || i2 != indents.peek() || isChildOf(context, new_node, parent, abbreviation_context_map) == false))
                              || (i2 == i1 && (indents.size() != 0 && i2 == indents.peek() && isChildOf(context, new_node, parent, abbreviation_context_map) == false))) {
                          i1 = indents.pop();
                          parent = nodes.pop();
                          if (debug) { System.err.println(String.format("POPPED  %8d%8d[%2d]%4d  %16s%16s%16s[%2d] %16s", i2, i1, indents.size(), indents.size() == 0 ? -1 : indents.peek(), format(context, new_node), format(context, last), format(context, parent), nodes.size(), nodes.size() == 0 ? "---" : format(context, nodes.peek()))); }
                      }
                      if (i2 < i1  && (indents.size() != 0 && i2 == indents.peek() && isChildOf(context, new_node, parent, abbreviation_context_map) == true)) {
                          i1 = i2;
                          if (debug) { System.err.println(String.format("ADJUST  %8d%8d[%2d]%4d  %16s%16s%16s[%2d] %16s", i2, i1, indents.size(), indents.size() == 0 ? -1 : indents.peek(), format(context, new_node), format(context, last), format(context, parent), nodes.size(), nodes.size() == 0 ? "---" : format(context, nodes.peek()))); }
                      }
                      if (i1 != i2) {
                          CustomaryContext.create((Context)context).throwConfigurationError(context, "While parsing MDOCP '%(info)', in line '%(line)' an unexpected indentation was encountered, it must match some previous level", "line", getPosition(context), "info", source_info);
                          {if (true) throw (ExceptionConfigurationError) null;} // compiler insists
                      }
                  }
                  parent.addPart(context, new_node);
                  last = new_node;
                  if (debug) { System.err.println(String.format("ADDED   %8d%8d[%2d]%4d  %16s%16s%16s[%2d] %16s", i2, i1, indents.size(), indents.size() == 0 ? -1 : indents.peek(), format(context, new_node), format(context, last), format(context, parent), nodes.size(), nodes.size() == 0 ? "---" : format(context, nodes.peek()))); }
              }
          break;
        case AT:
          Abbreviation(context, abbreviations, default_names_map, abbreviation_context_map, default_ocpmetavalues_map);
          break;
        default:
          jj_la1[56] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
    }
    jj_consume_token(0);
    while (i1 > i0) {
        i1 = indents.pop();
        parent = nodes.pop();
        if (debug) { System.err.println(String.format("POPPED  %8d%8d[%2d]%4d  %16s%16s%16s[%2d] %16s", -1, i1, indents.size(), indents.size() == 0 ? -1 : indents.peek(), "---", format(context, last), format(context, parent), nodes.size(), nodes.size() == 0 ? "---" : format(context, nodes.peek()))); }
    }
    {if (true) return root;}
    throw new Error("Missing return statement in function");
  }

  public MDOCPParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[58];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x1000,0x18,0x9020,0xd038,0xd038,0x9038,0x44,0x2,0x2,0xd038,0x90b8,0x2,0x2,0xd038,0x2,0xd038,0x2,0xf038,0xf038,0xd038,0x2,0x2002,0x2002,0xd038,0xd038,0x2,0x2,0x4000,0x2,0x2,0x2000,0x2,0x800,0x2,0x800,0x2,0x802,0x802,0x2,0x2,0x2,0x2,0x200,0x2,0x2,0x4000,0x44,0x2,0x4000,0x2,0x44,0x2,0x2,0x2,0x44,0x2,0xd038,0xd038,};
   }

  public MDOCPParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public MDOCPParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MDOCPParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
  }

  public MDOCPParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MDOCPParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
  }

  public MDOCPParser(MDOCPParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
  }

  public void ReInit(MDOCPParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[16];
    for (int i = 0; i < 16; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 58; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 16; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
